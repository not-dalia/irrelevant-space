---
layout: default
html_id: note
---
<div class="note-wrapper">
  <h1><span>{{ page.title }}</span></h1>
  <div class="info">
    <div class="note-type">{% if page.type and page.type != nil %}{{page.type}}{% else %}Note{% endif %}</div>
    <div class="separator">●</div>
    <div class="age">Created {{ page.created_at | timeago }}</div>
    <div class="separator">●</div>
    <div class="age">Last updated {{ page.last_modified_at | timeago }}</div>
  </div>
  <div class="note-content">
    <div class="main-col">
      {{ content }}
    </div>
    <div class="side-col">
      <div class="backlink-wrapper">
        <h2>Note Mentions</h2>
        <ul id="backlinks">
          <p>Fetching mentions...</p>
        </ul>
      </div>
    </div>
  </div>
  <div id="link-preview" role="tooltip">
    <div id="link-preview-content">
      <p>Consectetur ea exercitation id pariatur eiusmod pariatur non eiusmod id velit irure pariatur proident. Elit
        ullamco ut dolore id sint occaecat veniam adipisicing Lorem consequat enim consequat. Deserunt velit velit
        aliqua culpa incididunt magna aliquip exercitation sunt Lorem. Enim dolore cupidatat velit magna eu consequat
        velit culpa enim eiusmod. Culpa in proident proident do excepteur nulla quis mollit officia ex qui sint commodo
        magna. Non nostrud fugiat reprehenderit eu minim. Officia labore eiusmod anim tempor ad elit.</p>

      <p>Ad officia magna adipisicing commodo nulla in labore magna adipisicing. Pariatur esse laboris eiusmod officia
        quis proident sunt exercitation irure officia ex eu. Minim esse esse ad exercitation magna velit minim enim
        voluptate reprehenderit ad. Nostrud cillum dolor reprehenderit aute Lorem ipsum ullamco qui incididunt nostrud
        dolore.</p>
    </div>
  </div>
</div>

<script>
  let pageUrl = '{{ page.url }}';
  fetch('/scripts/backlinks.json')
    .then(response => response.json())
    .then(data => {
      let backlinks = data[pageUrl];
      if (backlinks) {
        let backlinksDiv = document.getElementById('backlinks');
        backlinksDiv.innerHTML = backlinks.filter(link => {
          let currentUrl = new URL(window.location.href);
          let linkUrl = new URL(`${currentUrl.origin}${link.url[0] == '/' ? '' : '/'}${link.url}`);
          let linkPathname = linkUrl.pathname.replace(/\/$/, '');
          let currentPathname = currentUrl.pathname.replace(/\/$/, '');
          return linkPathname != currentPathname;
        }).map(link =>
          `<li><a href="${link.url}">${link.title}</a></li>`).join('');
      } else {
        let backlinksDiv = document.getElementById('backlinks');
        backlinksDiv.innerHTML = 'No mentions';
      }
    });
</script>

<script>
  let isHoveringLink = false;
  let isHoveringPreview = false;

  function prepareLinkPreviews() {
    let linkPreview = document.getElementById('link-preview');
    let linkPreviewContent = document.getElementById('link-preview-content');
    let links = document.querySelectorAll('a.internal-link:not(.wikilink-embed a):not(.embed-link):not(.broken-link)');
    links.forEach(link => {
      link.addEventListener('mouseover', (e) => {
        isHoveringLink = true;
        showLinkPreview(link);
      });
      link.addEventListener('mouseout', (e) => {
        isHoveringLink = false;
        if (!isHoveringPreview) {
          let linkPreview = document.getElementById('link-preview');
          setTimeout(() => {
            if (!isHoveringPreview && !isHoveringLink) {
              hidePreview();
            }
          }, 200);
        }
      });


      link.addEventListener('focus', () => {
        showLinkPreview(link);
      });

      link.addEventListener('blur', () => {
        hidePreview();
      });
    });
    linkPreview.addEventListener('mouseenter', () => {
      isHoveringPreview = true;
    });

    linkPreview.addEventListener('mouseleave', () => {
      isHoveringPreview = false;
      if (!isHoveringLink) {
        hidePreview();
      }
    });
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        hidePreview();
      }
    });
  }

  function positionPreview(link, linkPreview) {
    const linkRect = link.getBoundingClientRect();
    const previewRect = linkPreview.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const spaceAbove = linkRect.top - previewRect.height - scrollTop;
    const spaceBelow = window.innerHeight - linkRect.bottom - previewRect.height + scrollTop;
    const margin = 30;
    const pageWidth = document.documentElement.clientWidth;

    if (spaceAbove >= 0 || previewRect.bottom <= scrollTop) {
      linkPreview.style.top = `${linkRect.top - previewRect.height - margin + scrollTop}px`;
    } else {
      linkPreview.style.top = `${linkRect.top + 22 - margin + scrollTop}px`;
    }

    // Check if preview overflows to the right
    if (link.offsetLeft + previewRect.width > pageWidth) {
      linkPreview.style.left = `${Math.max(0, pageWidth - previewRect.width - margin * 2)}px`;
    } else {
      linkPreview.style.left = `${Math.max(0, link.offsetLeft - margin * 2)}px`;
    }
  }

  function showLinkPreview(link) {
    let linkPreview = document.getElementById('link-preview');
    let linkPreviewContent = document.getElementById('link-preview-content');
    linkPreviewContent.innerHTML = 'Loading...';

    positionPreview(link, linkPreview);

    let linkUrl = link.href;
    if (linkUrl[0] == '#') return;
    fetch(linkUrl)
      .then(response => response.text())
      .then(data => {
        let parser = new DOMParser();
        let doc = parser.parseFromString(data, 'text/html');
        let title = doc.querySelector('.note-wrapper h1').innerText;
        let content = '';
        let preview = '';

        if (linkUrl.includes('#')) {
          const fragmentId = linkUrl.split('#')[1];
          const fragmentEl = doc.getElementById(fragmentId);
          if (fragmentEl) {
            const headers = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6'];
            const nextHeaders = headers.slice(headers.indexOf(fragmentEl.tagName) + 1);
            const elements = [fragmentEl];
            let nextEl = fragmentEl.nextElementSibling;
            while (nextEl && !nextHeaders.includes(nextEl.tagName)) {
              elements.push(nextEl);
              nextEl = nextEl.nextElementSibling;
            }
            content = elements.map(el => el.outerHTML).join('');
            preview = `<div>${content}</div>`;
          } else {
            content = doc.querySelector('.note-wrapper .note-content .main-col').innerHTML;
            preview = `<h2>${title}</h2><div>${content}</div>`;
          }
        } else {
          content = doc.querySelector('.note-wrapper .note-content .main-col').innerHTML;
          preview = `<h2>${title}</h2><div>${content}</div>`;
        }



        linkPreviewContent.innerHTML = preview;

        let callouts = linkPreviewContent.querySelectorAll('.obsidian-callout');
        callouts.forEach(callout => {
          fixCallout(callout);
        });
        lucide.createIcons();
        linkPreview.classList.add('visible');
        linkPreview.setAttribute('aria-hidden', 'false');
      });
  }

  function hidePreview() {
    let linkPreview = document.getElementById('link-preview');
    linkPreview.classList.remove('visible');
    linkPreview.setAttribute('aria-hidden', 'false');
  }
  prepareLinkPreviews();
</script>

<script src="https://unpkg.com/lucide@latest"></script>

<script>
  let callouts = document.querySelectorAll('.obsidian-callout');
  callouts.forEach(callout => {
    fixCallout(callout);
  });
  lucide.createIcons();

  function fixCallout(callout) {
    if (callout.classList.contains('formatted-callout')) return;
    let innerCallouts = callout.querySelectorAll('.obsidian-callout');
    innerCallouts.forEach(innerCallout => {
      fixCallout(innerCallout);
    });
    let calloutType = callout.getAttribute('data-type');
    let calloutTitle = callout.getAttribute('data-title')?.trim();
    let calloutContent = callout.innerHTML.trim();
    let calloutProperties = getCalloutProperties(calloutType);
    let calloutColor = calloutProperties.color;
    let calloutIcon = calloutProperties.icon;
    let calloutName = calloutProperties.name;
    let calloutTitleElement = `<div class="obsidian-callout-title"><i class="callout-icon" icon-name="${calloutIcon}"></i>${calloutTitle}</div>`;
    if (callout.classList.contains('callout-foldable')) {
      let calloutId = `callout-${Math.random().toString(36).substr(2, 9)}`;
      callout.setAttribute('id', calloutId);
      let expanded = callout.classList.contains('folded') ? 'false' : 'true';
      calloutTitleElement = `
        <button class="obsidian-callout-title" role="button" aria-expanded="false" aria-label="Toggle callout" tabindex="0" onclick="toggleCallout(this)" aria-controls="${calloutId}" aria-expanded="${expanded}">
          <i class="callout-icon" icon-name="${calloutIcon}"></i>
          <span class="callout-title-text">${calloutTitle}</span>
          <i class="callout-icon callout-icon-toggle" icon-name="chevron-down"></i>
        </button>
      `;
    }
    callout.classList.add('formatted-callout');
    callout.classList.add(`obsidian-callout-${calloutName}`);
    let calloutHtml = `
        ${calloutTitleElement}
        <div class="callout-content">${calloutContent}</div>
    `;
    callout.innerHTML = calloutHtml;
  }

  function toggleCallout(element) {
    let calloutId = element.getAttribute('aria-controls');
    let callout = document.getElementById(calloutId);
    let calloutTitle = callout.querySelector('.obsidian-callout-title');
    let calloutContent = callout.querySelector('.callout-content');
    let calloutIcon = callout.querySelector('.callout-icon-toggle');
    let isExpanded = !callout.classList.contains('folded');
    calloutTitle.setAttribute('aria-expanded', !isExpanded);
    calloutContent.setAttribute('aria-hidden', isExpanded);
    if (isExpanded) {
      callout.classList.add('folded');
    } else {
      callout.classList.remove('folded');
    }
  }

  function getCalloutProperties(type) {
    switch (type) {
      case 'abstract': case 'summary': case 'tldr':
        return {
          name: 'abstract',
          icon: 'clipboard-list',
        };
      case 'info':
        return {
          name: 'info',
          icon: 'info',
        };
      case 'todo':
        return {
          name: 'todo',
          icon: 'check-circle-2',
        };
      case 'tip': case 'hint': case 'important':
        return {
          name: 'tip',
          icon: 'flame',
        };
      case 'warning': case 'caution': case 'attention':
        return {
          name: 'warning',
          icon: 'alert-triangle',
        };
      case 'failure': case 'fail': case 'missing':
        return {
          name: 'failure',
          icon: 'x',
        };
      case 'success': case 'check': case 'done':
        return {
          name: 'success',
          icon: 'check',
        };
      case 'question': case 'faq': case 'help':
        return {
          name: 'question',
          icon: 'help-circle',
        };
      case 'danger': case 'error':
        return {
          name: 'danger',
          icon: 'zap',
        };
      case 'bug':
        return {
          name: 'bug',
          icon: 'bug',
        };
      case 'example':
        return {
          name: 'example',
          icon: 'list',
        };
      case 'quote':
        return {
          name: 'quote',
          icon: 'quote',
        };
      default:
        return {
          name: 'note',
          icon: 'pencil',
        };
    }
  }
</script>
