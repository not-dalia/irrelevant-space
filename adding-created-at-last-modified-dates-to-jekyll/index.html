<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="/assets/favicon.svg" type="image/x-icon">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fira+Code&amp;family=Frank+Ruhl+Libre:wght@300;400;500;600;700&amp;family=Raleway:ital,wght@0,400;0,500;0,600;0,700;1,400&amp;display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/styles/styles.css">
  <link rel="stylesheet" href="/styles/tango.css">
  <title>Irrelevant Space - Adding "Created At" and "Last Updated" Dates to Jekyll</title>
</head>

<body id="home">
  <header>
    <h1><a href="/">irrelevant space</a></h1>
    <div class="nav">
      <a href="/notes">notes</a>
      <a href="/endeavours">endeavours</a>
    </div>
  </header>

  <main>
    <div class="col-wrapper" id="note-header">
  <div class="main-col">
    <div class="info">
      <div class="note-type">note</div>
      
      <div class="separator">●</div>
      <div class="age">Created 10 Jan 2024</div>
      <div class="separator">●</div>
      <div class="age">Last updated <date datetime="2024-01-10T02:06:02+00:00">10 Jan 2024</date>
</div>
    </div>
    <h1><span>Adding "Created At" and "Last Updated" Dates to Jekyll</span></h1>
    
  </div>
</div>

<div class="content-wrapper" id="note-content">
  <div class="col-wrapper">
    <div class="main-col">
      <p>In making the Jekyll theme I am using here, I wanted each note to show a Created At and a Last Updated date. Jekyll by default supports dates for post types. The date would be specified in the title of the post, e.g. <code class="language-plaintext highlighter-rouge">2020-08-01-My-Post-Title.md</code>. The date is then parsed by Jekyll and is available in <code class="language-plaintext highlighter-rouge">post.date</code>. Since I’m using collections instead of posts, and mainly using Obsidian to create and edit my files, my markdown files as they are being generated at the moment don’t have a date in the title. I was already writing a set of plugins to add Obsidian support to Jekyll, so I thought I’d write a plugin that tells Jekyll to use the file’s creation date as the post date unless it is specified in the frontmatter.</p>

<h2 id="the-first-failed-attempt">The First (Failed) Attempt</h2>
<p>This was simple enough. All I had to do was to add a <code class="language-plaintext highlighter-rouge">:documents :post_init</code> hook<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote internal-link" rel="footnote">1</a></sup> to set the <code class="language-plaintext highlighter-rouge">created_at</code> and <code class="language-plaintext highlighter-rouge">last_updated_at</code> variables to <code class="language-plaintext highlighter-rouge">File.ctime(doc.path)</code><sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote internal-link" rel="footnote">2</a></sup> and <code class="language-plaintext highlighter-rouge">File.mtime(doc.path)</code><sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote internal-link" rel="footnote">3</a></sup> respectively if they are not already set in the frontmatter. The resulting code looks something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Jekyll</span><span class="o">::</span><span class="no">Hooks</span><span class="p">.</span><span class="nf">register</span> <span class="ss">:documents</span><span class="p">,</span> <span class="ss">:post_init</span> <span class="k">do</span> <span class="o">|</span><span class="n">doc</span><span class="o">|</span>
  <span class="c1"># set created at date to file creation date if not already set</span>
  <span class="n">doc</span><span class="p">.</span><span class="nf">data</span><span class="p">[</span><span class="s2">"created_at"</span><span class="p">]</span> <span class="o">||=</span> <span class="no">File</span><span class="p">.</span><span class="nf">ctime</span><span class="p">(</span><span class="n">doc</span><span class="p">.</span><span class="nf">path</span><span class="p">)</span>

  <span class="c1"># set last updated date to file modification date if not already set</span>
  <span class="n">doc</span><span class="p">.</span><span class="nf">data</span><span class="p">[</span><span class="s2">"last_updated_at"</span><span class="p">]</span> <span class="o">||=</span> <span class="no">File</span><span class="p">.</span><span class="nf">mtime</span><span class="p">(</span><span class="n">doc</span><span class="p">.</span><span class="nf">path</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This worked perfectly when I was testing it locally. But once pushed to GitHub, all the notes showed the same date, the date of when they were pushed to GitHub. What was going on?</p>

<p>  </p>
<blockquote class="wikilink-embed wikilink-asset-embed" data-config="500">
<a href="/assets/itworksonmymachine.jpg" class="internal-link embed-link" data-embed-url="/assets/itworksonmymachine.jpg" data-embed-fragment="">500</a><div class="asset-embed meadow-embed"><img src="/assets/itworksonmymachine.jpg" alt="Image: ItWorksOnMyMachine" width="500"></div>  </blockquote>
<span style="font-size: 0.9rem; text-align: center; display: block; margin-top: -1.2rem;">Source: <a href="https://simply-the-test.blogspot.com/2010/05/it-works-on-my-machine.html" class="external-link" target="_blank">It works on my machine</a></span>

<h3 id="what-was-going-on">What was going on?</h3>
<p>To understand the issue, it is important to understand the deployment setup. When a new commit gets pushed to GitHub, a GitHub action is triggered which uses <a href="https://github.com/actions/checkout" class="external-link" target="_blank"><code class="language-plaintext highlighter-rouge">actions/checkout@v4</code></a> to checkout the repo, then uses a custom action that is not relevant to this post to build the site and deploy it to GitHub Pages. When <code class="language-plaintext highlighter-rouge">actions/checkout@v4</code> checks out the repo, all the files were being created at the same time, which is the time of the checkout. This is why <code class="language-plaintext highlighter-rouge">File.ctime</code> and <code class="language-plaintext highlighter-rouge">File.mtime</code> are unsuitable for this case. What we need instead is a way to get the creation date of the file in the repo, not the creation date of the file in the local machine.</p>

<h2 id="the-second-working-attempt">The Second (Working) Attempt</h2>
<p>My next plan was to use git history to set <code class="language-plaintext highlighter-rouge">created_at</code> to the file’s first commit date, and the <code class="language-plaintext highlighter-rouge">last_updated_at</code> to the file’s last commit date. By default, <code class="language-plaintext highlighter-rouge">actions/checkout@v4</code> checks out the repo with the <code class="language-plaintext highlighter-rouge">fetch-depth</code> option set to 1, so only the latest commit is fetched. Since I need the full git history to get the first commit date as well as the last, the GitHub actions workflow needed a small tweak:</p>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code> - name: Checkout
   uses: actions/checkout@v4
<span class="gi">+  with:
+    fetch-depth: 0 # fetch all history for all tags and branches
</span></code></pre></div></div>

<p>Now that we have the full git history, we can use <code class="language-plaintext highlighter-rouge">git log</code> <sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote internal-link" rel="footnote">4</a></sup> to get the first and last commit dates. Using <code class="language-plaintext highlighter-rouge">git log --follow --format=%ad --date=iso-strict -- "#{doc.path}"</code> we get a list of all the commit dates for the file from latest to oldest. We parse the list and assign the first and last lines to <code class="language-plaintext highlighter-rouge">last_updated_at</code> and <code class="language-plaintext highlighter-rouge">created_at</code>. A rough idea of the final code is:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Jekyll</span><span class="o">::</span><span class="no">Hooks</span><span class="p">.</span><span class="nf">register</span> <span class="ss">:documents</span><span class="p">,</span> <span class="ss">:post_init</span> <span class="k">do</span> <span class="o">|</span><span class="n">doc</span><span class="o">|</span>
  <span class="n">git_dates_log_command</span> <span class="o">=</span> <span class="sb">`git log --follow --format=%ad --date=iso-strict -- "</span><span class="si">#{</span><span class="n">doc</span><span class="p">.</span><span class="nf">path</span><span class="si">}</span><span class="sb">"`</span>
  <span class="n">git_dates</span> <span class="o">=</span> <span class="n">git_dates_log_command</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
  <span class="n">doc</span><span class="p">.</span><span class="nf">data</span><span class="p">[</span><span class="s2">"created_at"</span><span class="p">]</span> <span class="o">||=</span> <span class="n">git_dates</span><span class="p">.</span><span class="nf">first</span>
  <span class="n">doc</span><span class="p">.</span><span class="nf">data</span><span class="p">[</span><span class="s2">"last_updated_at"</span><span class="p">]</span> <span class="o">||=</span> <span class="n">git_dates</span><span class="p">.</span><span class="nf">last</span>
<span class="k">end</span>
</code></pre></div></div>

<blockquote class="meadow-callout  formatted-callout meadow-callout-warning" data-type="warning" data-title="Warning">
<div class="meadow-callout-title">
<i class="meadow-callout-icon" icon-name="alert-triangle"></i><span>Warning</span>
</div>
<div class="meadow-callout-content"><p>The above snippet is just a rough idea of what could work. Don’t use it as it is. The next section gives some pointers on how to improve it.</p></div>
</blockquote>

<h2 id="things-to-keep-in-mind">Things to Keep in Mind</h2>

<h3 id="1-check-that-the-dates-are-valid">1. Check that the dates are valid</h3>
<p>The first and last lines of the <code class="language-plaintext highlighter-rouge">git log</code> output might not be valid dates. For example, git might output a warning or an error message instead of a date. Blindly assigning the first and last lines to <code class="language-plaintext highlighter-rouge">created_at</code> and <code class="language-plaintext highlighter-rouge">last_updated_at</code> might result in breaking the build. So it is important to check that the dates are valid and that they are actually on the first and last lines.</p>

<h3 id="2-allow-for-overriding-the-dates-in-the-frontmatter">2. Allow for overriding the dates in the frontmatter</h3>
<p>While this is a neat trick, the priority should always be given to the dates specified in the frontmatter.</p>

<h3 id="3-to-follow-or-not-to-follow">3. To –follow or not to –follow</h3>
<p>The <code class="language-plaintext highlighter-rouge">--follow</code> <sup id="fnref:5" role="doc-noteref"><a href="#fn:5" class="footnote internal-link" rel="footnote">5</a></sup> option in <code class="language-plaintext highlighter-rouge">git log</code> is used to follow the history of a file across renames. Is a renamed post a new post or an update to an existing post? That’s your decision.</p>

<h3 id="4-avoid-using-timeago-for-post-dates">4. Avoid using timeago for post dates</h3>
<p>After hours of trying to figure out why Jekyll was still showing “Today” for a post I modified last week, I remembered that I am using the <code class="language-plaintext highlighter-rouge">timeago</code> filter from <a href="https://github.com/markets/jekyll-timeago" class="external-link" target="_blank"><code class="language-plaintext highlighter-rouge">jekyll-timeago</code></a> plugin. I was rendering the dates using <code class="language-plaintext highlighter-rouge">{{ doc.last_modified_at | timeago }}</code>. Now as you know Jekyll is a <strong>static</strong> site generator, and it renders this as HTML at the time of build, and <strong><u>only</u></strong> then. This means any date rendered with <code class="language-plaintext highlighter-rouge">timeago</code> is hardcoded as is in the HTML and won’t change until the next build. I switched all the dates to the <code class="language-plaintext highlighter-rouge">"%-d %b %y"</code> format for now. Might use <a href="https://momentjs.com/" class="external-link" target="_blank"><code class="language-plaintext highlighter-rouge">moment.js</code></a> in the future to get the <code class="language-plaintext highlighter-rouge">timeago</code> dates back.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p><a href="https://jekyllrb.com/docs/plugins/hooks/" class="external-link" target="_blank">Jekyll Hooks</a> are a way to run code at specific points in the Jekyll build process. The <code class="language-plaintext highlighter-rouge">:documents :post_init</code> hook runs after the documents have been read and parsed, but before it is rendered. <a href="#fnref:1" class="reversefootnote internal-link" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p><a href="https://ruby-doc.org/core-2.5.1/File.html#method-c-ctime" class="external-link" target="_blank">File.ctime</a> returns the creation time of the file. <a href="#fnref:2" class="reversefootnote internal-link" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p><a href="https://ruby-doc.org/core-2.5.1/File.html#method-c-mtime" class="external-link" target="_blank">File.mtime</a> returns the last modification time of the file. <a href="#fnref:3" class="reversefootnote internal-link" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p><a href="https://git-scm.com/docs/git-log" class="external-link" target="_blank">git log</a> shows the commit logs. <a href="#fnref:4" class="reversefootnote internal-link" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:5" role="doc-endnote">
      <p><a href="https://git-scm.com/docs/git-log#Documentation/git-log.txt---follow" class="external-link" target="_blank">git log –follow</a> follows the history of a file across renames. <a href="#fnref:5" class="reversefootnote internal-link" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

    </div>
    <div class="side-col">
      
      <div class="note-side-wrapper card">
        <h2>Topics</h2>
        <div class="topics">
          
          <a href="/topics/jekyll">Jekyll</a>
          
          <a href="/topics/web-development">Web development</a>
          
        </div>
      </div>
      

      <div class="note-side-wrapper card">
        <h2>Mentions</h2>
        <ul id="backlinks">
          <p>Fetching mentions...</p>
        </ul>
      </div>
    </div>
  </div>
</div>

<div id="link-preview" role="tooltip">
  <div id="link-preview-content">

  </div>
</div>

<script>
  let pageUrl = '/adding-created-at-last-modified-dates-to-jekyll/';
  fetch('/scripts/backlinks.json')
    .then(response => response.json())
    .then(data => {
      let backlinks = data[pageUrl];
      if (backlinks && backlinks.length > 0) {
        let backlinksDiv = document.getElementById('backlinks');
        backlinksDiv.innerHTML = backlinks.filter(link => {
          let currentUrl = new URL(window.location.href);
          let linkUrl = new URL(`${currentUrl.origin}${link.url[0] == '/' ? '' : '/'}${link.url}`);
          let linkPathname = linkUrl.pathname.replace(/\/$/, '');
          let currentPathname = currentUrl.pathname.replace(/\/$/, '');
          return linkPathname != currentPathname;
        }).map(link =>
          `<li><a href="${link.url}">${link.title}</a></li>`).join('');
      } else {
        let backlinksDiv = document.getElementById('backlinks');
        backlinksDiv.innerHTML = 'No mentions from other notes';
      }
    });
</script>

<script>
  let isHoveringLink = false;
  let isHoveringPreview = false;

  function prepareLinkPreviews() {
    let linkPreview = document.getElementById('link-preview');
    let linkPreviewContent = document.getElementById('link-preview-content');
    let links = document.querySelectorAll('a.internal-link:not(.wikilink-embed a):not(.embed-link):not(.broken-link):not(.reversefootnote)');
    links.forEach(link => {
      link.addEventListener('mouseover', (e) => {
        isHoveringLink = true;
        showLinkPreview(link);
      });
      link.addEventListener('mouseout', (e) => {
        isHoveringLink = false;
        if (!isHoveringPreview) {
          let linkPreview = document.getElementById('link-preview');
          setTimeout(() => {
            if (!isHoveringPreview && !isHoveringLink) {
              hidePreview();
            }
          }, 200);
        }
      });


      link.addEventListener('focus', () => {
        showLinkPreview(link);
      });

      link.addEventListener('blur', () => {
        hidePreview();
      });
    });
    linkPreview.addEventListener('mouseenter', () => {
      isHoveringPreview = true;
    });

    linkPreview.addEventListener('mouseleave', () => {
      isHoveringPreview = false;
      if (!isHoveringLink) {
        hidePreview();
      }
    });
    document.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        hidePreview();
      }
    });
  }

  function positionPreview(link, linkPreview) {
    const linkRect = link.getBoundingClientRect();
    const previewRect = linkPreview.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const spaceAbove = linkRect.top - previewRect.height - scrollTop;
    const spaceBelow = window.innerHeight - linkRect.bottom - previewRect.height + scrollTop;
    const margin = 30;
    const pageWidth = document.documentElement.clientWidth;

    if (spaceAbove >= 0 || previewRect.bottom <= scrollTop) {
      linkPreview.style.top = `${linkRect.top - previewRect.height - margin + scrollTop}px`;
    } else {
      linkPreview.style.top = `${linkRect.top + 22 - margin + scrollTop}px`;
    }

    // Check if preview overflows to the right
    if (link.offsetLeft + previewRect.width > pageWidth) {
      linkPreview.style.left = `${Math.max(0, pageWidth - previewRect.width - margin * 2)}px`;
    } else {
      linkPreview.style.left = `${Math.max(0, link.offsetLeft - margin * 2)}px`;
    }
  }

  function showLinkPreview(link) {
    let linkPreview = document.getElementById('link-preview');
    let linkPreviewContent = document.getElementById('link-preview-content');
    linkPreviewContent.innerHTML = 'Loading...';

    positionPreview(link, linkPreview);

    let linkUrl = link.href;
    if (linkUrl[0] == '#') return;
    fetch(linkUrl)
      .then(response => response.text())
      .then(data => {
        let parser = new DOMParser();
        let doc = parser.parseFromString(data, 'text/html');
        let title = doc.querySelector('#note-header h1').innerText;
        let content = '';
        let preview = '';

        if (linkUrl.includes('#')) {
          console.log(linkUrl);
          const fragmentId = linkUrl.split('#')[1];
          const fragmentEl = doc.getElementById(fragmentId);
          const headers = ['H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'LI'];
          if (fragmentEl && headers.indexOf(fragmentEl.tagName)) {
            const nextHeaders = headers.slice(headers.indexOf(fragmentEl.tagName));
            const elements = [fragmentEl];
            let nextEl = fragmentEl.nextElementSibling;
            while (nextEl && !nextHeaders.includes(nextEl.tagName)) {
              elements.push(nextEl);
              nextEl = nextEl.nextElementSibling;
            }
            content = elements.map(el => el.outerHTML).join('');
            preview = `<div>${content}</div>`;
          } else {
            content = doc.querySelector('#note-content .main-col').innerHTML;
            preview = `<h2>${title}</h2><div>${content}</div>`;
          }
        } else {
          content = doc.querySelector('#note-content .main-col').innerHTML;
          preview = `<h2>${title}</h2><div>${content}</div>`;
        }

        linkPreviewContent.innerHTML = preview;

        lucide.createIcons();
        linkPreview.classList.add('visible');
        linkPreview.setAttribute('aria-hidden', 'false');
      });
  }

  function hidePreview() {
    let linkPreview = document.getElementById('link-preview');
    linkPreview.classList.remove('visible');
    linkPreview.setAttribute('aria-hidden', 'false');
  }
  prepareLinkPreviews();
</script>

<script src="https://unpkg.com/lucide@latest"></script>

<script>
  lucide.createIcons();

  function toggleMeadowCallout(element) {
    let calloutId = element.getAttribute('aria-controls');
    let callout = document.getElementById(calloutId);
    let calloutTitle = callout.querySelector('.meadow-callout-title');
    let calloutContent = callout.querySelector('.meadow-callout-content');
    let calloutIcon = callout.querySelector('.meadow-callout-icon-toggle');
    let isExpanded = !callout.classList.contains('folded');
    calloutTitle.setAttribute('aria-expanded', !isExpanded);
    calloutContent.setAttribute('aria-hidden', isExpanded);
    if (isExpanded) {
      callout.classList.add('folded');
    } else {
      callout.classList.remove('folded');
    }
  }
</script>

  </main>
</body>

</html>
